# Import Gym Dependencies
import gym
import pygame
import mazeEscapeGame
from ClassesMazeEscape.LOCATIONS import LOCATIONS
from ClassesMazeEscape.AGENT import AGENT
from ClassesMazeEscape.ENVIRONMENT import ENVIRONMENT
from gym import Env
from gym.spaces import Discrete, Box, Dict, Tuple, MultiBinary, MultiDiscrete

# Importing Helper Libraries
import numpy as np
import random
import os

# Importing Stable-Baselines3 Stuff
from stable_baselines3 import ppo
from stable_baselines3.common.vec_env import dummy_vec_env
from stable_baselines3.common.evaluation import evaluate_policy

# Observing what the spaces look like
print(Discrete(3).sample())
print(Box(low=0, high=1, shape=(4,4)).sample())
print(Tuple((Discrete(1), Discrete(10))).sample())
print(Dict({"Position": Discrete(2), "Velocity": Discrete(3)}).sample())
print(MultiBinary([3,3]).sample())
print(MultiDiscrete([10,2,3,4]).sample())

# Simulated Environment: 
"""
To escape a 5x5 hex maze, agent starts on one hex, and must avoid obstacles to find the most optimized path to the end
action_space: can move left, right, up, down
"""
class mazeEscape(Env):
    # metadata = {"render_modes": ["human"], "render_fps":5}
    def __init__(self, render_mode = None, fieldSize = 8, map = None) -> None:
        self.fieldSize = fieldSize
        self.windowsWidth = mazeEscapeGame.windowsWidth
        self.windowsHeight = mazeEscapeGame.windowsHeight
        self.textAreaHeight = mazeEscapeGame.textAreaHeight
        self.gameDisplay = None

        self.map = map
        if self.map == None:
            locations = LOCATIONS(fieldSize, self.windowsWidth, self.windowsHeight)
            self.map = locations.getMap()
        self.environment = ENVIRONMENT(fieldSize, self.windowsWidth, self.windowsHeight, self.map)
        self.agent = AGENT(fieldSize, self.windowsWidth, self.windowsHeight, self.map)

        self.action_space = Discrete(4) # 4 possible actions: up, down, left, right
        # self.observation_space = 4 # current location on the board

    def step(self, action):
        """
        Take an action from the action space and have the RL model apply it to the board
        """
        self.agent.move(action)
        pass

    def render(self, mode = "human"):
        """
        Render and show the current state of the game, where the agent's at and what the current map looks like
        """
        # assert mode in ["human"], "Invalid mode, must be \"human\""
        if mode == "human" and self.gameDisplay == None:
            self.gameDisplay = mazeEscapeGame.initializePygame()
        
        mazeEscapeGame.renderEnvironment(self.gameDisplay, self.environment, self.fieldSize, self.windowsWidth, self.windowsHeight)
        mazeEscapeGame.generateBlankEnvironment(self.gameDisplay, self.fieldSize)
        mazeEscapeGame.putText(self.gameDisplay, "Round:{}, Score:{}".format(round, self.agent.getScore()), (self.windowsWidth//2, self.windowsHeight+self.textAreaHeight//2))
        pygame.display.update()

    def reset(self):
        """
        Resets the agent to the start and resets the map
        """
        pass

    def play(self):
        """
        Allows the user to play the game
        """
        mazeEscapeGame.playGame()

    # def loadEnvironment(self, map):
    #     """
    #     Loads a specific environment from input map
    #     """
    #     self.map = map